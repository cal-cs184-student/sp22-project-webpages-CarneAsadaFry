<html>
	<head>
	</head>
	<body>
		<h1> Project 2 </h1>
		<h2> Task 1 </h2>
		<p>
			To implement de Casteljau's algorithm, we lerp each pair of adjacent control points
		that make up the Bezier curve to get new points in between. Then, we lerp each adjacent pair of lerped points, 
		and we repeat recursively until we only have one point left. This is a point on the Bezier curve.
		By varying the lerp parameter between 0 and 1, we get all of the points on the Bezier curve. </p>
		<h3> De Casteljau Example: Cusp </h3>
		<img src="bzc0.png" width="791" height="592">
		<img src="bzc1.png" width="791" height="592">
		<img src="bzc2.png" width="791" height="592">
		<img src="bzc3.png" width="791" height="592">
		<img src="bzc4.png" width="791" height="592">
		<img src="bzc5.png" width="791" height="592">
		<img src="bzc6.png" width="791" height="592">
		<h3> Full Example: Cusp </h3>
		<img src="bzc_full.png" width="791" height="592">
		<h3> Shifted Cusp, Modified t </h3>
		<img src="bzc_shift.png" width="791" height="592">
		<h2> Task 2 </h2>
		<p> To extend the algorithm, we first apply the algorithm to each row to get a sequence of control points that describe a Bezier curve
			perpendicular to the rows, and then we apply the algorithm to this sequence of points to get a single point on the Bezier curve.
			The parameter u between 0 and 1 determines our lerps on each row, and the parameter v determines the lerps of the points from
			each row. Varying v gives us the entire Bezier curve perpendicular to the rows, and varying u gives us different Bezier curves
			that are perpendicular to the rows. By varying both, we form the entire surface. </p>
		<h3> Teapot </h3>
		<img src="teapot.png" width="791" height="592">
		
		<h2> Task 3 </h2>
		<p>To implement area-weighted vertex normals, we first took a half-edge from the vertex. Then, to get each face, we took the face associated
		with the half edge, then took twin->next before repeating. We stopped when returning to the original half edge. Given each face, we computed
		the area-weighted normal by computing the sum of the cross products between each pair of vertices along the face (by going around with half edges),
		which will give us the direction of the normal weighted by area times some constant. Then, to compute the vertex normal, we simply add 
		these area weighted normals and then make the vector a unit vector, so the additional constant vactor on the area weighted normals does
			not effect the calculation.</p>
		<h3> Flat Shading </h3>
		<img src="flat_shading.png" width="791" height="592">	
		<h3> Phong Shading </h3>
		<img src="phong_shading.png" width="791" height="592">
		
		<h2> Task 4 </h2>
		We started by making a drawing of an edge and the two triangles it interfaces with. We labeled all relevant quantities.
		<h3> Diagram </h3>
		<img src="drawing.jpg" width="398" height="600">
		<p> If the edge was on the boundary, we immediately returned it and went no futher.
		If it was not on the boundary, we first fetched all of the relevant quantities using the half edge associated with the edge.
		Then, we first reassigned next for h, h1, and h4 so they point to each other. We then reassigned next for t (twin of h), h2, and h3 so they also 
		point in a loop. Then, we changed h4 to have face f1, and made f1 have half edge h1. We also made h2 have face f2 and f2 have half edge h2.
		Then, we made h have vertex v1 and v1 have half edge h. Finally, we made t have vertex v2 and v2 have half edge t. In the end, we did not
		have to make any changes to the edge e0, since it was still associated with the same half edge. By making careful use of the diagram,
		we were able to get all of the rules correct on the first try, so debugging was not necessary for us. Thus, we didn't really develop
			any significant debugging tricks, besides simply referencing our diagram. </p>
		<h3> Before Flipping </h3>
		<img src="unflipped.png" width="791" height="592">
		<h3> After Flipping </h3>
		<img src="flipped.png" width="791" height="592">
		<p> The one debugging piece we did have to do was replace CIter with Iter, because we realized that nothing could be changed when using CIters. </p>
		
	</body>
</html>

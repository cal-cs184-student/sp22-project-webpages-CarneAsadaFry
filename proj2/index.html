<html>
	<head>
	</head>
	<body>
		<h1> Project 2 </h1>
		<h2> Task 1 </h2>
		<p>
			To implement de Casteljau's algorithm, we lerp each pair of adjacent control points
		that make up the Bezier curve to get new points in between. Then, we lerp each adjacent pair of lerped points, 
		and we repeat recursively until we only have one point left. This is a point on the Bezier curve.
		By varying the lerp parameter between 0 and 1, we get all of the points on the Bezier curve. </p>
		<h3> De Casteljau Example: Cusp </h3>
		<img src="bzc0.png" width="791" height="592">
		<img src="bzc1.png" width="791" height="592">
		<img src="bzc2.png" width="791" height="592">
		<img src="bzc3.png" width="791" height="592">
		<img src="bzc4.png" width="791" height="592">
		<img src="bzc5.png" width="791" height="592">
		<img src="bzc6.png" width="791" height="592">
		<h3> Full Example: Cusp </h3>
		<img src="bzc_full.png" width="791" height="592">
		<h3> Shifted Cusp, Modified t </h3>
		<img src="bzc_shift.png" width="791" height="592">
		<h2> Task 2 </h2>
		<p> To extend the algorithm, we first apply the algorithm to each row to get a sequence of control points that describe a Bezier curve
			perpendicular to the rows, and then we apply the algorithm to this sequence of points to get a single point on the Bezier curve.
			The parameter u between 0 and 1 determines our lerps on each row, and the parameter v determines the lerps of the points from
			each row. Varying v gives us the entire Bezier curve perpendicular to the rows, and varying u gives us different Bezier curves
			that are perpendicular to the rows. By varying both, we form the entire surface. </p>
		<h3> Teapot </h3>
		<img src="teapot.png" width="791" height="592">
		
		<h2> Task 3 </h2>
		<p>To implement area-weighted vertex normals, we first took a half-edge from the vertex. Then, to get each face, we took the face associated
		with the half edge, then took twin->next before repeating. We stopped when returning to the original half edge. Given each face, we computed
		the area-weighted normal by computing the sum of the cross products between each pair of vertices along the face (by going around with half edges),
		which will give us the direction of the normal weighted by area times some constant. Then, to compute the vertex normal, we simply add 
		these area weighted normals and then make the vector a unit vector, so the additional constant vactor on the area weighted normals does
			not effect the calculation.</p>
		<h3> Flat Shading </h3>
		<img src="flat_shading.png" width="791" height="592">	
		<h3> Phong Shading </h3>
		<img src="phong_shading.png" width="791" height="592">
		
		<h2> Task 4 </h2>
		<p>We started by making a drawing of an edge and the two triangles it interfaces with. We labeled all relevant quantities.</p>
		<h3> Diagram </h3>
		<img src="drawing.jpg" width="398" height="600">
		<p> If the edge was on the boundary, we immediately returned it and went no futher.
		If it was not on the boundary, we first fetched all of the relevant quantities using the half edge associated with the edge.
		Then, we first reassigned next for h, h1, and h4 so they point to each other. We then reassigned next for t (twin of h), h2, and h3 so they also 
		point in a loop. Then, we changed h4 to have face f1, and made f1 have half edge h1. We also made h2 have face f2 and f2 have half edge h2.
		Then, we made h have vertex v1 and v1 have half edge h. Finally, we made t have vertex v2 and v2 have half edge t. In the end, we did not
		have to make any changes to the edge e0, since it was still associated with the same half edge. By making careful use of the diagram,
		we were able to get all of the rules correct on the first try, so debugging was not necessary for us. Thus, we didn't really develop
			any significant debugging tricks, besides simply referencing our diagram. </p>
		<h3> Before Flipping </h3>
		<img src="unflipped.png" width="791" height="592">
		<h3> After Flipping </h3>
		<img src="flipped.png" width="791" height="592">
		<p> The one debugging piece we did have to do was replace CIter with Iter, because we realized that nothing could be changed when using CIters. </p>
		
		<h2> Task 5 </h2>
		<p>We started by again making a diagram of an edge and the two triangles it interfaces with, and then expanding that diagram into a diagram of four
			triangles with split edges. We again labeled all relevant quantities.</p>
		<h3> Diagram </h3>
		<img src="drawing2.jpg" width="398" height="600">
		<p> Again, we immediately returned if an edge was on the boundary. If the edge was not on the boundary, we again first fetched all existing
			labeeled quantities using the half edge structure, and then we created all the new halfedges, vertices, and so on using the appropriate
			functions. Then, using the diagram, we went through each object (halfedge, vertex, edge, face) and updated each of its pointers to
			match with what we had on the diagram. We did not have any major implementation tricks besides using the diagram. As a debugging trick,
			we used the provided check_for method, to check how many things pointed to each vertex, which ultimately revealed the biggest bug
			that we encountered in our code.</p>
		<h3> Before Splitting </h3>
		<img src="normal.png" width="791" height="592">
		<h3> After Splitting </h3>
		<img src="split.png" width="791" height="592">
		<h3> After Splitting and Flipping </h3>
		<img src="split_flip.png" width="791" height="592">
		<p> After implementing the updates in our diagrams, we found that the program would crash upon trying to split an edge. After running through
			the function, we found that it was only crashing after our function call ended. Next, we used the included check_for function to look
			at where each of our objects was referenced. When doing this, we found that some vertices were being referenced by 7 halfedges when they
			should have only been referenced by 6. This made us realize that there was some halfedge which was not gettings its parameters updated.
			Sure enough, looking back, we realized we had to forgot to update the halfedges h and t in our diagram, and had simply left their original
			parameters. Fixing this also fixed our bug. Luckily, this was the only serious bug we encountered in this part.</p>
	</body>
</html>

<html>
	<head>
	</head>
	<body>
		<h1> Project 2 </h1>
		<h2> Task 1 </h2>
		<p>
			To implement de Casteljau's algorithm, we lerp each pair of adjacent control points
		that make up the Bezier curve to get new points in between. Then, we lerp each adjacent pair of lerped points, 
		and we repeat recursively until we only have one point left. This is a point on the Bezier curve.
		By varying the lerp parameter between 0 and 1, we get all of the points on the Bezier curve. </p>
		<h3> De Casteljau Example: Cusp </h3>
		<img src="bzc0.png" width="791" height="592">
		<img src="bzc1.png" width="791" height="592">
		<img src="bzc2.png" width="791" height="592">
		<img src="bzc3.png" width="791" height="592">
		<img src="bzc4.png" width="791" height="592">
		<img src="bzc5.png" width="791" height="592">
		<img src="bzc6.png" width="791" height="592">
		<h3> Full Example: Cusp </h3>
		<img src="bzc_full.png" width="791" height="592">
		<h3> Shifted Cusp, Modified t </h3>
		<img src="bzc_shift.png" width="791" height="592">
		<h2> Task 2 </h2>
		<p> To extend the algorithm, we first apply the algorithm to each row to get a sequence of control points that describe a Bezier curve
			perpendicular to the rows, and then we apply the algorithm to this sequence of points to get a single point on the Bezier curve.
			The parameter u between 0 and 1 determines our lerps on each row, and the parameter v determines the lerps of the points from
			each row. Varying v gives us the entire Bezier curve perpendicular to the rows, and varying u gives us different Bezier curves
			that are perpendicular to the rows. By varying both, we form the entire surface. </p>
		<h3> Teapot </h3>
		<img src="teapot.png" width="791" height="592">
		
		<h2> Task 3 </h2>
		To implement area-weighted vertex normals, we first took a half-edge from the vertex. Then, to get each face, we took the face associated
		with the half edge, then took twin->next before repeating. We stopped when returning to the original half edge. Given each face, we computed
		the area-weighted normal by computing the sum of the cross products between each pair of vertices along the face (by going around with half edges),
		which will give us the direction of the normal weighted by area times some constant. Then, to compute the vertex normal, we simply add 
		these area weighted normals and then make the vector a unit vector, so the additional constant vactor on the area weighted normals does
		not effect the calculation.
		<h3> Flat Shading </h3>
		<img src="flat_shading.png" width="791" height="592">	
		<h3> Phong Shading </h3>
		<img src="phong_shading.png" width="791" height="592">
	</body>
</html>

<html>
	<head>
	</head>
	<body>
		<h1>Project 1</h1>
		<h2>Task 1</h2>
		<p>
		To rasterize the triangles, we first computed the bounding box for the triangle. This was done by looking at the min and max x and y values across all vertices.
		Thus, our algorithm is no slower than looking at every point in the bounding box, since this is what we did.
		We then perform three line tests for each point in the bounding box, first assuming a counterclockwise orientation and then a clockwise orientation for the edges of the triangle.
		If the point was found to be inside the triangle for either of the orientations, we fill the pixel.
		We also implemented the OpenGL edge rules. To do this, we looked at the case where pixels lay on an edge. Then, we determined if it was a top edge by seeing if the two 
		y values of the edge were equal. To see if it was a left edge, we saw if the edge "went up" (y1<y2) in the counterclockwise case or "went down" (y1>y2) in the
		clockwise case, since this characterizes a left edge. In these two cases, we fill the pixel. Else, we left it blank.
		</p>
		<h3> Test 4 </h3>
		<img src="test4_green.png" width="791" height="592">
		
		<h2>Task 2</h2>
		<p>To supersample, we used an array, sample_buffer, of size width * height * sample_rate. Then, we sampled the image at sqrt(sample_rate) by sqrt(sample_rate)
		points per pixel, saving the color at each point in the sample buffer. Then, after doing this for all triangles, we average color values that are in the
		same pixel within the sample_buffer, and save this averaged value to the frame buffer.</p>
		<h3> Test 4, Sample Rate 1 </h3>
		<img src="test4_1ss.png" width="791" height="592">
		<h3> Test 4, Sample Rate 4 </h3>
		<img src="test4_4ss.png" width="791" height="592">
		<h3> Test 4, Sample Rate 16 </h3>
		<img src="test4_16ss.png" width="791" height="592">
		
		<p>We see a difference because super sampling approximates a box blur, and a box blur has the effect of removing high frequencies, which will lower
		the Nyquist rate of the image to a point closer to our sampling frequency. When we sample far below the Nyquist rate, we get aliasing which
		we notice in the image. So, by eliminiating the high frequencies, some of the aliasing is also eliminated and the image looks better to us.</p>
		
		<h2>Task 3 </h2>
		<p> We made cubeman dance, putting one leg in the air and one arm up. We also made him many different colors so he is more festive. <\p>
		<h3> Cubeman </h3>
		<img src="dancing.png" width="791" height="592">
			
		<h2> Task 4 </h2>
		<p> The image below helps demonstrate barycentric coordinates. We fix a value (in this case a color) at each vertex of the triangle. Then, at each point,
		we assign the color to be a linear combination of the colors at the vertices, where the coefficients are the proportional distances of the point from
		each vertex. So, we get a gradient that smoothly transitions between each vertex of the triangle. </p>
		<img src="triangle.png" width="791" height="592">
		<h3> Test 7 </h3>
		<img src="test7.png" width="791" height="592">	
			
		<h2> Task 5 </h2>
		<p>In pixel sampling, we take a triangle that has texture coordinates (uv coordinates) associated with each vertex. Then, we interpolate the uv coordinates 
		across the entire triangle using barycentric coordinate. Thus, each point on the triangle has a uv coordinate associated with it. Then, we sample points
		on the triangle (either in the center of each pixel or in more places if supersampling is enabled) and use the uv coordinate to get the corresponding
		color by sampling at those coordinates on the texture. Once we have the color, we can follow the normal supersampling algorithm. 
		When sampling the color from the texture, we can either use nearest sampling, where we simply take the color of the texel closest to the given uv coordinate,
		or we can use bilinear sampling, where we take the colors of the four texels closest to the uv coordinate, and then linearly interpolate two pairs, then
		linearly interpolate the results of the interpolations to get a single color.</p>
		<h3> Nearest, Supersample rate 1 </h3>
		<img src="nearest_1ss.png" width="791" height="592">
		<h3> Bilinear, Supersample rate 1 </h3>
		<img src="bilinear_1ss.png" width="791" height="592">
		<h3> Nearest, Supersample rate 16 </h3>
		<img src="nearest_16ss.png" width="791" height="592">
		<h3> Bilinear, Supersample rate 16 </h3>
		<img src="bilinear_16ss.png" width="791" height="592">
		<p> Comparing the images with supersampling rate 1, we see that the bilinear samplings smooths the high frequency transitions between different
		colors, which eliminates jaggies and makes the image look better. This happens because we are essentially blurring our sampling of the texels
		and eliminating high frequency signals which cause aliasing. We also see an improvement in the supersampling rate 16 images for the same reason,
		but the effect is more subtle because the supersampling already eliminates high frequencies.</p>
		<p>In general, the bilinear sampling will be better in regions with many high frequencies, such as when there is a quick color transition in
		the texture image. It works better because the bilinear sampling acts as a blur, as discussed above, and so it eliminates the high frequencies
		that cause aliasing.</p>
	</body>
</html>
